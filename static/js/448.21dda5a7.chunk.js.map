{"version":3,"file":"static/js/448.21dda5a7.chunk.js","mappings":"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","sources":["framework/visualisation/react/ui/workers/visualizationDataFunctions/util.ts","framework/visualisation/react/ui/workers/visualizationDataFunctions/prepareChartData.ts","framework/visualisation/react/ui/workers/visualizationDataFunctions/prepareTextData.ts","framework/visualisation/react/ui/workers/visualizationDataWorker.ts"],"sourcesContent":["import { PropsUITable, TableContext } from '../../../../../types/elements'\nimport { DateFormat } from '../../../../../types/visualizations'\n\nexport function autoFormatDate (dateNumbers: number[], minValues: number): DateFormat {\n  const minTime = Math.min(...dateNumbers)\n  const maxTime = Math.max(...dateNumbers)\n\n  let autoFormat: DateFormat = 'hour'\n  if (maxTime - minTime > 1000 * 60 * 60 * 24 * minValues) autoFormat = 'day'\n  if (maxTime - minTime > 1000 * 60 * 60 * 24 * 30 * minValues) autoFormat = 'month'\n  if (maxTime - minTime > 1000 * 60 * 60 * 24 * 30 * 3 * minValues) autoFormat = 'quarter'\n  if (maxTime - minTime > 1000 * 60 * 60 * 24 * 365 * minValues) autoFormat = 'year'\n\n  return autoFormat\n}\n\nexport function formatDate (\n  dateString: string[],\n  format: DateFormat,\n  minValues: number = 10\n): [string[], number[] | null] {\n  let formattedDate: string[] = dateString\n  const dateNumbers = dateString.map((date) => new Date(date).getTime())\n  let sortableDate: number[] | null = null\n\n  if (format === 'auto') format = autoFormatDate(dateNumbers, minValues)\n\n  if (format === 'year') {\n    formattedDate = dateNumbers.map((date) => new Date(date).getFullYear().toString())\n    sortableDate = dateNumbers\n  }\n  if (format === 'quarter') {\n    formattedDate = dateNumbers.map((date) => {\n      const year = new Date(date).getFullYear().toString()\n      const quarter = Math.floor(new Date(date).getMonth() / 3) + 1\n      return `${year}-Q${quarter}`\n    })\n    sortableDate = dateNumbers\n  }\n  if (format === 'month') {\n    formattedDate = dateNumbers.map((date) => {\n      const year = new Date(date).getFullYear().toString()\n      const month = new Date(date).toLocaleString('default', { month: 'short' })\n      return year + '-' + month\n    })\n    sortableDate = dateNumbers\n  }\n  if (format === 'day') {\n    formattedDate = dateNumbers.map((date) => new Date(date).toISOString().split('T')[0])\n    sortableDate = dateNumbers\n  }\n  if (format === 'hour') {\n    formattedDate = dateNumbers.map(\n      (date) => new Date(date).toISOString().split('T')[1].split(':')[0]\n    )\n    sortableDate = dateNumbers\n  }\n  if (format === 'month_cycle') {\n    const formatter = new Intl.DateTimeFormat('default', { month: 'long' })\n    formattedDate = dateNumbers.map((date) => formatter.format(new Date(date)))\n    sortableDate = dateNumbers.map((date) => new Date(date).getMonth())\n  }\n  if (format === 'weekday_cycle') {\n    const formatter = new Intl.DateTimeFormat('default', { weekday: 'long' })\n    formattedDate = dateNumbers.map((date) => formatter.format(new Date(date)))\n    sortableDate = dateNumbers.map((date) => new Date(date).getDay())\n  }\n  if (format === 'day_cycle') {\n    const formatter = new Intl.DateTimeFormat('default', { day: 'numeric' })\n    formattedDate = dateNumbers.map((date) => formatter.format(new Date(date)))\n    sortableDate = dateNumbers.map((date) => new Date(date).getDay())\n  }\n  if (format === 'hour_cycle') {\n    const formatter = new Intl.DateTimeFormat('default', { hour: 'numeric' })\n    formattedDate = dateNumbers.map((date) => formatter.format(new Date(date)))\n    sortableDate = dateNumbers.map((date) => new Date(date).getHours())\n  }\n\n  return [formattedDate, sortableDate]\n}\n\nexport function tokenize (text: string): string[] {\n  const tokens = text.split(' ')\n  return tokens.filter((token) => /\\p{L}/giu.test(token)) // only tokens with word characters\n}\n\nexport function getTableColumn (table: PropsUITable & TableContext, column: string): string[] {\n  const columnIndex = table.head.cells.findIndex((cell) => cell.text === column)\n  if (columnIndex < 0) throw new Error(`column ${table.id}.${column} not found`)\n  return table.body.rows.map((row) => row.cells[columnIndex].text)\n}\n\nexport function rescaleToRange (\n  value: number,\n  min: number,\n  max: number,\n  newMin: number,\n  newMax: number\n): number {\n  return ((value - min) / (max - min)) * (newMax - newMin) + newMin\n}\n","import { formatDate, getTableColumn } from './util'\nimport { PropsUITable, TableContext } from '../../../../../types/elements'\nimport {\n  TickerFormat,\n  ChartVisualizationData,\n  ChartVisualization\n} from '../../../../../types/visualizations'\n\nexport async function prepareChartData (\n  table: PropsUITable & TableContext,\n  visualization: ChartVisualization\n): Promise<ChartVisualizationData> {\n  const visualizationData: ChartVisualizationData = {\n    type: visualization.type,\n    xKey: {\n      label:\n        visualization.group.label !== undefined\n          ? visualization.group.label\n          : visualization.group.column\n    },\n    yKeys: {},\n    data: []\n  }\n\n  if (table.body.rows.length === 0) return visualizationData\n\n  // First get the unique values of the x column\n  const rowIds = table.body.rows.map((row) => row.id)\n\n  let groupBy = getTableColumn(table, visualization.group.column)\n  // KASPER CHECK: I think the first clause in the statement can go\n  // getTableColumn will return a string array or errs out\n  // so only check for length is still doing something\n  if (groupBy.length === 0) {\n    throw new Error(`X column ${table.id}.${visualization.group.column} not found`)\n  }\n  let xSortable: Array<string | number> | null = null // separate variable allows using epoch time for sorting dates\n\n  // ADD CODE TO TRANSFORM TO DATE, BUT THEN ALSO KEEP AN INDEX BASED ON THE DATE ORDER\n  if (visualization.group.dateFormat !== undefined) {\n    ;[groupBy, xSortable] = formatDate(groupBy, visualization.group.dateFormat)\n  }\n\n  const aggregate: Record<string, PrepareAggregatedData> = {}\n  for (const value of visualization.values) {\n    const aggFun = value.aggregate !== undefined ? value.aggregate : 'count'\n    let tickerFormat: TickerFormat = 'default'\n    if (aggFun === 'pct' || aggFun === 'count_pct') tickerFormat = 'percent'\n\n    const yValues = getTableColumn(table, value.column)\n    // KASPER CHECK\n    if (yValues.length === 0) throw new Error(`Y column ${table.id}.${value.column} not found`)\n\n    // If group_by column is specified, the columns in the aggregated data will be the unique group_by columns\n    const yGroup = value.group_by !== undefined ? getTableColumn(table, value.group_by) : null\n\n    // if missing values should be treated as zero, we need to add the missing values after knowing all groups\n    const addZeroes = value.addZeroes ?? false\n    const groupSummary: Record<string, { n: number, sum: number }> = {}\n    const uniqueGroups = new Set<string>([])\n\n    for (let i = 0; i < groupBy.length; i++) {\n      const xValue = groupBy[i]\n      const yValue = yValues[i]\n      const group =\n        yGroup != null ? yGroup[i] : value.label !== undefined ? value.label : value.column\n      if (addZeroes) uniqueGroups.add(group)\n      const sortBy = xSortable != null ? xSortable[i] : groupBy[i]\n\n      // calculate group summary statistics. This is used for the mean, pct and count_pct aggregations\n      if (groupSummary[group] === undefined) groupSummary[group] = { n: 0, sum: 0 }\n      if (aggFun === 'count_pct' || aggFun === 'mean') groupSummary[group].n += 1\n      if (aggFun === 'pct') groupSummary[group].sum += Number(yValue) ?? 0\n\n      // add the AxisSettings for the yKeys in this loop, because we need to get the unique group values from the data (if group_by is used)\n      if (visualizationData.yKeys[group] === undefined) {\n        visualizationData.yKeys[group] = {\n          label: group,\n          secondAxis: value.secondAxis !== undefined,\n          tickerFormat\n        }\n      }\n\n      if (aggregate[xValue] === undefined) {\n        aggregate[xValue] = {\n          sortBy: sortBy,\n          rowIds: {},\n          xLabel: visualizationData.xKey.label,\n          xValue: String(xValue),\n          values: {}\n        }\n      }\n      if (aggregate[xValue].rowIds[group] === undefined) aggregate[xValue].rowIds[group] = []\n      aggregate[xValue].rowIds[group].push(rowIds[i])\n\n      if (aggregate[xValue].values[group] === undefined) aggregate[xValue].values[group] = 0\n      if (aggFun === 'count' || aggFun === 'count_pct') aggregate[xValue].values[group] += 1\n      if (aggFun === 'sum' || aggFun === 'mean' || aggFun === 'pct') {\n        aggregate[xValue].values[group] += Number(yValue) ?? 0\n      }\n    }\n\n    Object.keys(groupSummary).forEach((group) => {\n      for (const xValue of Object.keys(aggregate)) {\n        if (aggregate[xValue].values[group] === undefined) {\n          if (addZeroes) aggregate[xValue].values[group] = 0\n          else continue\n        }\n        if (aggFun === 'mean') {\n          aggregate[xValue].values[group] =\n            Number(aggregate[xValue].values[group]) / groupSummary[group].n\n        }\n        if (aggFun === 'count_pct') {\n          aggregate[xValue].values[group] =\n            (100 * Number(aggregate[xValue].values[group])) / groupSummary[group].n\n        }\n        if (aggFun === 'pct') {\n          aggregate[xValue].values[group] =\n            (100 * Number(aggregate[xValue].values[group])) / groupSummary[group].sum\n        }\n      }\n    })\n  }\n\n  visualizationData.data = Object.values(aggregate)\n    .sort((a: any, b: any) => (a.sortBy < b.sortBy ? -1 : b.sortBy < a.sortBy ? 1 : 0))\n    .map((d) => {\n      for (const key of Object.keys(d.values)) d.values[key] = Math.round(d.values[key] * 100) / 100\n      return {\n        ...d.values,\n        [d.xLabel]: d.xValue,\n        __rowIds: d.rowIds,\n        __sortBy: d.sortBy\n      }\n    })\n\n  return visualizationData\n}\n\nexport interface PrepareAggregatedData {\n  xLabel: string\n  xValue: string\n  values: Record<string, number>\n  rowIds: Record<string, string[]>\n  sortBy: number | string\n}\n","import { getTableColumn, rescaleToRange, tokenize } from './util'\nimport { PropsUITable, TableContext } from '../../../../../types/elements'\nimport {\n  TextVisualizationData,\n  TextVisualization,\n  ScoredTerm\n} from '../../../../../types/visualizations'\n\ninterface VocabularyStats {\n  value: number\n  docFreq: number\n}\n\nexport async function prepareTextData (\n  table: PropsUITable & TableContext,\n  visualization: TextVisualization\n): Promise<TextVisualizationData> {\n  const visualizationData: TextVisualizationData = {\n    type: visualization.type,\n    topTerms: []\n  }\n\n  if (table.body.rows.length === 0) return visualizationData\n\n  const texts = getTableColumn(table, visualization.textColumn)\n  const values =\n    visualization.valueColumn != null ? getTableColumn(table, visualization.valueColumn) : null\n\n  const vocabulary = getVocabulary(texts, values, visualization)\n  visualizationData.topTerms = getTopTerms(vocabulary, texts.length, 200)\n\n  return visualizationData\n}\n\nfunction getVocabulary (\n  texts: string[],\n  values: string[] | null,\n  visualization: TextVisualization\n): Record<string, VocabularyStats> {\n  const vocabulary: Record<string, VocabularyStats> = {}\n\n  for (let i = 0; i < texts.length; i++) {\n    if (texts?.[i] == null) continue\n    const text = texts[i]\n    const tokens =\n      visualization.tokenize != null && visualization.tokenize ? tokenize(text) : [text]\n\n    const seen = new Set<string>()\n    for (const token of tokens) {\n      if (vocabulary[token] === undefined) vocabulary[token] = { value: 0, docFreq: 0 }\n      if (!seen.has(token)) {\n        vocabulary[token].docFreq += 1\n        seen.add(token)\n      }\n      const v = Number(values?.[i]) ?? 1\n      if (!isNaN(v)) vocabulary[token].value += v\n    }\n  }\n  return vocabulary\n}\n\nfunction getTopTerms (\n  vocabulary: Record<string, VocabularyStats>,\n  nDocs: number,\n  topTerms: number\n): ScoredTerm[] {\n  const words = Object.entries(vocabulary)\n    .map(([text, stats]) => {\n      const tf = Math.log(1 + stats.value)\n      const idf = Math.log(nDocs / stats.docFreq)\n      return { text, value: stats.value, importance: tf * idf }\n    })\n    .sort((a, b) => b.importance - a.importance)\n    .slice(0, topTerms)\n\n  const minImportance = Math.min(...words.map((w) => w.importance))\n  const maxImportance = Math.max(...words.map((w) => w.importance))\n\n  return words.map((w) => {\n    return {\n      text: w.text,\n      value: w.value,\n      importance: rescaleToRange(w.importance, minImportance, maxImportance, 0, 1)\n    }\n  })\n}\n","import { PropsUITable, TableContext, TableWithContext } from '../../../../types/elements'\nimport {\n  ChartVisualization,\n  TextVisualization,\n  VisualizationType,\n  VisualizationData\n} from '../../../../types/visualizations'\nimport { prepareChartData } from './visualizationDataFunctions/prepareChartData'\nimport { prepareTextData } from './visualizationDataFunctions/prepareTextData'\n\ninterface Input {\n  table: TableWithContext\n  visualization: VisualizationType\n}\n\nself.onmessage = (e: MessageEvent<Input>) => {\n  createVisualizationData(e.data.table, e.data.visualization)\n    .then((visualizationData) => {\n      self.postMessage({ status: 'success', visualizationData })\n    })\n    .catch((error) => {\n      console.error(error)\n      self.postMessage({ status: 'error', visualizationData: undefined })\n    })\n}\n\nasync function createVisualizationData (\n  table: PropsUITable & TableContext,\n  visualization: VisualizationType\n): Promise<VisualizationData> {\n  if (table === undefined || visualization === undefined) throw new Error('Table and visualization are required')\n\n  if (['line', 'bar', 'area'].includes(visualization.type)) { return await prepareChartData(table, visualization as ChartVisualization) }\n\n  if (['wordcloud'].includes(visualization.type)) { return await prepareTextData(table, visualization as TextVisualization) }\n\n  throw new Error(`Visualization type ${visualization.type} not supported`)\n}\n"],"names":["autoFormatDate","dateNumbers","minValues","minTime","Math","min","maxTime","max","autoFormat","tokenize","text","split","filter","token","test","getTableColumn","table","column","columnIndex","head","cells","findIndex","cell","Error","id","body","rows","map","row","rescaleToRange","value","newMin","newMax","async","prepareChartData","visualization","visualizationData","type","xKey","label","undefined","group","yKeys","data","length","rowIds","groupBy","xSortable","dateFormat","dateString","format","formattedDate","date","Date","getTime","sortableDate","getFullYear","toString","year","quarter","floor","getMonth","toLocaleString","month","toISOString","formatter","Intl","DateTimeFormat","weekday","getDay","day","hour","getHours","formatDate","aggregate","values","aggFun","tickerFormat","yValues","yGroup","group_by","addZeroes","groupSummary","uniqueGroups","Set","i","xValue","yValue","add","sortBy","n","sum","Number","secondAxis","xLabel","String","push","Object","keys","forEach","sort","a","b","d","key","round","__rowIds","__sortBy","prepareTextData","topTerms","texts","textColumn","vocabulary","tokens","seen","docFreq","has","v","isNaN","getVocabulary","valueColumn","nDocs","words","entries","stats","tf","log","idf","importance","slice","minImportance","w","maxImportance","getTopTerms","self","onmessage","e","includes","createVisualizationData","then","postMessage","status","catch","error","console"],"sourceRoot":""}